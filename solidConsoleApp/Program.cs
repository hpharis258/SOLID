Console.WriteLine("SOLID Principles - Single Responsibility Principle (SRP)");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("1. User Class: Responsible for user data and adding to mailing list.");
Console.WriteLine("2. FileLogger Class: Responsible for logging messages to a file.");
Console.WriteLine("3. ILogger Interface: Defines the contract for logging.");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("SOLID Principles - Open/Closed Principle (OCP)");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("1. UserOCP abstract Class: is Open for extension, but closed for modification or change.");
Console.WriteLine("2. BronzeUserOCP Class: Inherits from UserOCP and implements GetDiscount method.");
Console.WriteLine("3. SilverUserOCP Class: Inherits from UserOCP and implements GetDiscount method.");
Console.WriteLine("4. The main benefit being that you can add new user types without modifying the existing code.");
Console.WriteLine("5. This means that you don't need to re-test the existing code when you add new functionality.");
Console.WriteLine("6. This is a simple example of how to implement the Open/Closed Principle in C#.");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("1. The Liskov Substitution Principle (LSP) states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.");
Console.WriteLine("2. In other words, if a class is a subclass of another class, it should be able to be used in place of the parent class without any issues.");
Console.WriteLine("3. This principle is important because it ensures that a program can be extended without breaking existing code.");
Console.WriteLine("4. It also helps to ensure that a class hierarchy is well-designed and that subclasses are truly substitutable for their parent classes.");
Console.WriteLine("5. In this example, we have a base class UserLSP and two derived classes RegisteredUserLSP and GuestUserLSP.");
Console.WriteLine("6. The base class UserLSP has an abstract method ResetPassword that is implemented in the derived classes.");
Console.WriteLine("7. The RegisteredUserLSP class implements the ResetPassword method to reset the password for registered users.");
Console.WriteLine("8. The GuestUserLSP class implements the ResetPassword method but returns false, indicating that guests cannot reset passwords.");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("SOLID Principles - Interface Segregation Principle (ISP)");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("1. The Interface Segregation Principle (ISP) states that no client should be forced to depend on methods it does not use.");
Console.WriteLine("2. This means that a class should not be forced to implement an interface that it does not use.");
Console.WriteLine("3. In this example, we have two separate interfaces: ISendEmail and ISendBulkEmail.");
Console.WriteLine("4. This way, we can pick and choose which interface we want to implement.");
Console.WriteLine("5. This is a good example of the Interface Segregation Principle.");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("SOLID Principles - Dependency Inversion Principle (DIP)");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("1. The Dependency Inversion Principle (DIP) states that high-level modules should not depend on low-level modules.");
Console.WriteLine("2. Both should depend on abstractions.");
Console.WriteLine("3. Abstractions should not depend on details. Details should depend on abstractions.");
Console.WriteLine("4. This means that a class should not depend on a concrete implementation of another class.");
Console.WriteLine("5. In this example, we have an interface IMessageService that defines the contract for sending messages.");
Console.WriteLine("6. The Notification class depends on the IMessageService interface, not on a concrete implementation of the Email class.");
Console.WriteLine("7. This means that we can change the implementation of the Email class without changing the Notification class.");
Console.WriteLine("8. This is a good example of the Dependency Inversion Principle.");
Console.WriteLine("--------------------------------------------------");
Console.WriteLine("Press any key to exit...");
Console.ReadKey();